<!DOCTYPE html>

<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>35</title>

    <link rel="stylesheet" href="../css/common.css">
</head>
<body>

    <div>

        <h4 class="note">&psi; (1) 배열 리터럴(Array Literal)로 생성하기</h4>

        <ul>
            <li class="note">배열 변수에 초기값을 할당하여 배열을 만드는 방법</li>
            <li class="note">(*중요*) 배열은 0개 이상의 원소를 가질 수 있음</li>
            <li>작성형식:<br/>
                <code class="note">
                    var 배열명 = { 원소1, 원소2, 원소3, ... }
                </code>
            </li>
            <li>배열원소의 접근: <b class="note">인덱스</b>를 통해 접근</li>
        </ul>


        <hr/>


        <script>

            console.log("---------------------------------------------------")

            var city = [ 'Seoul', 'Pusan', 'Incheon' ]      // 배열 리터럴로 배열 생성
            console.log("1. city:", city)


            function printArray() {                         // 함수선언
                console.log('>>> printArray() invoked.')

                var i

                for(i=0; i < city.length; i++) {
                    console.log('\t+ city[' + i + ']:', city[i])
                } // for
            } // printArray


            printArray()                                    // 함수호출

        </script>



        <ul>
            <li>배열에 저장될 원소의 개수를 알 수 없는 경우: <code>var arr=[] 와 같이 배열선언</code></li>
            <li>배열의 크기: 배열에 저장되는 원소의 개수만큼, 자동으로 설정</li>
            <li class="note">(*중요*) 즉, 배열변수부터 먼저 선언하고, 원소의 값은 따로 할당가능</li>
        </ul>

        <hr/>


        <script>

            console.log("---------------------------------------------------")

            var city = []                               // 빈 배열선언

            // 배열에 새로운 원소추가
            city[0] = 'Seoul'                   
            city[1] = 'Busan'
            city[2] = 'Incheon'
            city[3] = 'Mokpo'
            city[4] = 'Sejeong'

            console.log('2. city:', city)


            function printArr() {                       // 함수선언
                console.log('>>> printArr() invoked.')

                var i

                for(i=0; i < city.length; i++) {
                    console.log('\t+ city['+i+']:', city[i])
                } // for
            } // printArr

            printArr()                                  // 함수호출

        </script>


        <ul>
            <li>배열선언 시, 초기값을 할당하면서, 모든 원소를 명시할 필요는 없음</li>
            <li class="note">(*중요*) 배열의 해당 인덱스에 저장할 원소값이 정해지지 않았다면,<br/>공백으로 두고 쉼표(,) 찍은 후, 다음 원소 기재하면 됨</li>
            <li class="note">(*중요*) 배열은 명시되지 않은 원소의 값을 <b class="note">undefined</b> 로 처리</li>
            <li class="note">(*주의*) 공백 원소가 있는 배열의 연산시, 의도하지 않은 결과가 나올 수 있음</li>
        </ul>

        <hr/>


        <script>

            console.log("---------------------------------------------------")

            var city = [ 'Seoul', , 'Busan', , 'Incheon' ]  // 공백을 포함한 배열선언

            console.log('3. city:', city)


            function printArr() {       // 힘수선언
                console.log('>>> printArr() invoked.')

                var i

                for(i=0; i < city.length; i++) {
                    console.log('\t+ city['+ i + ']:', city[i])
                } // for
            } // printArr


            printArr()      // 함수호출

        </script>


        <ul>
            <li class="note">공백 원소가 있는 배열의 연산시, 의도하지 않은 결과가 나올 수 있음</li>
            <li>따라서, 공백 데이터를 제외한 값만 선택하여 연산하도록 제어문을 사용하여,<br/>공백 데이터를 제외시켜야 함</li>
        </ul>


        <script>

            console.log("---------------------------------------------------")

            // var scores = [ 95, 88, 72, 68, 99, 82, 78, 85 ]     // 배열에 공백이 포함되지 않은 경우
            var scores = [ 95, 88, 72, 68, 99,   , 78, 85 ]     // 배열에 공백이 포함되어 있는 경우

            console.log('4. scores:', scores)


            var getAvg


            function printAvg() {       // 함수선언
                console.log('>>> printAvg() invoked.')

                var i, sum = 0
                var n = scores.length

                for(i=0; i < n; i++) {
                    sum += scores[i]
                } // for

                return ( sum / n )
            } // printAvg


            getAvg = printAvg()                     // 함수호출
            console.log('\t+ getAvg:', getAvg)      // 함수호출결과: NaN (* 공백원소는 undefined로 처리함 *)

        </script>

        <hr/>


        <script>

            console.log("---------------------------------------------------")

            var scores = [ 95, 88,  , 72, 68, 99, 82, 78, 87]

            console.log('5. scores:', scores)


            var getAvg


            function printArr() {   // 함수선언
                console.log('>>> printArr() invoked.')
                
                var i
                var sum = 0
                var count = 0
                var n = scores.length

                console.log('\t+ '+n+'명의 점수입력')

                for(i=0; i < n; i++) {

                    if(scores[i] === undefined) {   // 공백원소이면...
                        continue                    // 연산에서 제외시킴
                    } // if

                    sum += scores[i]

                    ++count

                } // for

                console.log('\t+ 점수가 있는 학생:', count)
                console.log('\t+ 총합:', sum)

                return (sum / count)
            } // printArr

            getAvg = printArr()     // 함수호출
            console.log('\t+ getAvg:', getAvg)

        </script>


        <ul>
            <li>일반적으로 배열에는 같은 데이터 타입의 값만 저장</li>
            <li>하지만, 자바스크립트는 명시적인 타입이 없는 언어(Untyped language)임</li>
            <li class="note">따라서, 배열 원소의 데이터 타입도 반드시 같을 필요가 없음</li>
        </ul>

        <hr/>


        <script>

            console.log("---------------------------------------------------")

            var arr = [ 10, 20, 30, 40, 50 ]    // 배열 리터럴 선언

            console.log('6. arr:', arr)


            function printArr() {               // 함수선언
                console.log('>>> printArr() invoked.')

                var i, sum = 0

                for(i=0; i < arr.length; i++) {
                    sum += arr[i]
                } // for

                return sum
            } // printArr

            var result = printArr()             // 함수호출
            console.log('\t+ result =', result)

        </script>


        <script>

            console.log("---------------------------------------------------")

            var x = 5
            var arr = [ 100, 'Seoul', true, x ]     // 다양한 데이터 타입의 원소를 가지는 배열 리터럴 선언

            console.log('7. arr:', arr)


            function printArr() {                   // 함수선언
                console.log('>>> printArr() invoked.')

                var i

                for(i=0; i < arr.length; i++) {
                    console.log('\t+ arr['+i+']:', arr[i], ', typeof:', typeof arr[i])
                } // for
            } // printArr


            printArr()                              // 함수호출

        </script>


        <ul>
            <li class="note">(*중요*) 서로 다른 데이터 타입을 가진 배열을 연산하는 경우, 주의해야 함</li>
        </ul>


        <script>

            console.log("---------------------------------------------------")

            var arr = [ 10, 20, 30, 40, '50' ]     // 다양한 타입을 원소로 가지는 배열 리터럴 선언

            console.log('8. arr:', arr)

            
            function printArr() {                   // 함수선언
                console.log('>>> printArr() invoked.')

                var i, sum = 0

                for(i=0; i < arr.length; i++) {
                    sum += arr[i]
                } // for

                return sum
            } // printArr


            var result = printArr()                 // 함수호출
            console.log('\t+ result:', result)

        </script>

    </div>
    
</body>
</html>